# Data Model — NodeWeather

## 1. Загальна концепція

Застосунок працює з трьома основними типами даних:

- **Улюблені міста** — міста, які користувач часто переглядає та зберігає для швидкого доступу.
- **Історія переглядів** — записи про запити користувача до погодного сервісу.
- **Аналітика** — агрегована статистика, що обчислюється на основі історії (топ міст, кількість запитів тощо).

Для зберігання використовується вбудована база даних **SQLite**. Аналітика будується окремим сервісом на основі вже накопичених даних.

---

## 2. Структура БД

### 2.1 Таблиця `favorites`

Таблиця зберігає улюблені міста користувача.

```text
favorites
---------
id          INTEGER PRIMARY KEY AUTOINCREMENT
name        TEXT    NOT NULL UNIQUE    -- назва міста (унікальна)
lat         REAL    NOT NULL           -- широта
lon         REAL    NOT NULL           -- довгота
```

**Особливості:**

- Поле `name` оголошене унікальним, щоб не було дублювання улюблених міст.
- Широта та довгота використовуються для безпосереднього запиту до погодного API.
- Таблиця не залежить від інших сутностей — кожен запис самодостатній.

**Відповідні модулі:**

- DAL: `backend/src/dal/favorites.dal.js`
- Сервіс: `backend/src/services/favorites.service.js`
- Роутер: `backend/src/routes/favorites.route.js`

---

### 2.2 Таблиця `history`

Таблиця зберігає історію переглядів погоди користувачем.

```text
history
-------
id          INTEGER PRIMARY KEY AUTOINCREMENT
date        TEXT    NOT NULL           -- дата запиту у форматі YYYY-MM-DD
city        TEXT    NOT NULL           -- назва міста
temp        REAL                        -- температура на момент запиту
conditions  TEXT                        -- погодні умови у вигляді тексту
```

**Особливості:**

- Всі записи історії є незалежними, але можуть агрегуватися за:
  - датою (`date`);
  - містом (`city`).
- Поля `temp` та `conditions` можуть бути відсутні або `NULL`, якщо їх не вдалося отримати від погодного API.
- На основі `history` будується статистика (топ міст, кількість запитів за день тощо).

**Відповідні модулі:**

- DAL: `backend/src/dal/history.dal.js`
- Сервіс: `backend/src/services/history.service.js`
- Роутер: `backend/src/routes/history.route.js`
- Аналітика: `backend/src/dal/stats.dal.js`, `backend/src/services/stats.service.js`

---

## 3. Взаємозв’язки між сутностями

На рівні бази даних таблиці `favorites` та `history` не мають явних зовнішніх ключів одна до одної.  
Зв’язок між ними є **логічним** та реалізується на рівні сервісів:

- `favorites` — зберігає **поточний список обраних міст**;
- `history` — накопичує **усі перегляди погоди**, у тому числі і для міст, які не додані в обране;
- аналітичний сервіс `stats` використовує тільки таблицю `history` для побудови звітів.

Таке розділення:

- спрощує схему БД;
- дозволяє зберігати історію навіть після видалення міста з улюблених;
- не блокує зміну назви/координат обраних міст.

---

## 4. Потоки даних

### 4.1 Додавання улюбленого міста

1. Користувач у фронтенді обирає місто і натискає «Додати в улюблені».
2. Frontend викликає `POST /api/favorites` з тілом:

   ```json
   {
     "name": "Kyiv",
     "lat": 50.4501,
     "lon": 30.5234
   }
   ```

3. Сервіс `favorites.service` виконує валідацію та викликає DAL.
4. DAL вставляє запис у таблицю `favorites` (або ігнорує, якщо такий вже існує).
5. Frontend оновлює список улюблених міст.

### 4.2 Збереження запису історії

1. Після успішного отримання погоди frontend формує об’єкт:

   ```json
   {
     "date": "2025-11-30",
     "city": "Kyiv",
     "temp": 3.5,
     "conditions": "Light rain"
   }
   ```

2. Викликається `POST /api/history`.
3. Сервіс `history.service`:
   - за потреби встановлює поточну дату;
   - викликає DAL для вставки запису;
   - може обрізати історію до останніх N записів.
4. Frontend оновлює блок «Історія».

---

## 5. Використання моделі для аналітики

Аналітичний модуль працює **тільки на читання** з таблиць `history` та `favorites`.

Основні сценарії:

- `GET /api/stats/top-cities`:
  - групування записів `history` за полем `city`;
  - підрахунок кількості записів для кожного міста;
  - сортування за кількістю звернень;
  - повернення топ N міст.
- `GET /api/stats/overview`:
  - підрахунок загальної кількості записів у `history`;
  - підрахунок загальної кількості записів у `favorites`.
- `GET /api/stats/today`:
  - фільтрація таблиці `history` за вказаною датою;
  - повернення кількості запитів за день.

Таким чином:

- **модель даних** залишається простою (дві таблиці);
- **аналітика** реалізується на рівні SQL-запитів та сервісного шару без зміни схеми.

---

## 6. Відповідність вимогам ЛР

Оновлена модель даних відповідає вимогам лабораторної роботи:

- Описані основні сутності (улюблені міста, історія переглядів).
- Для кожної сутності наведена структура таблиць SQLite (типи полів, ключі, обмеження).
- Пояснено логічні зв’язки між сутностями (`favorites` ↔ `history` через сервісний рівень).
- Продемонстровано, як модель даних використовується для:
  - збереження інформації;
  - побудови історії;
  - формування аналітичних звітів (топ міст, лічильники, запити за день).
